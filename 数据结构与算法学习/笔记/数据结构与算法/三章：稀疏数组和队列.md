#### 一、稀疏数组

* 当一个数组中大部分元素为0，或者为同一个值得数组时，可以用稀疏数组来保存

* 处理方法：

  记录数组一共几行几列，有多少个不同的值

  把具有不同值的元素行列记录在一个小规模的数组中，从而缩小程序的规模


![1561377618134](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1561377618134.png)

 稀疏数组表现形式

|      | row    | col    | val            |
| ---- | ------ | ------ | -------------- |
| 0    | 共几行 | 共几列 | 共几个有效数据 |
| 1    | 第几行 | 第几列 | 值是多少       |
| 2    |        |        |                |

* 二维数组转稀疏数组

  1.遍历原始的二维数组，得到有效数据的个数sum

  2.根据sum创建稀疏数组 

  3.将二维数组的有效数据转入稀疏数组

* 稀疏转二维

  1.先读取第一行第一列创建二维数组

  2.读取后几行分别存入到相应二维数组中

[代码](E:\YangChengCan\Learning\数据结构与算法学习\代码\DataStructures\src\com\yangcc\sparearray)



### 二、队列

**用数组模拟队列**

![1561984624771](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1561984624771.png)

模拟类：队列头  队列尾   数组最大容量   存放数据的数组

* 问题  数组只能使用一次

 [代码](E:\YangChengCan\Learning\数据结构与算法学习\代码\DataStructures\src\com\yangcc\queue)

**数组模拟环形队列**

* 思路如下：

  1.front 含义调整：front 指向队列的第一个元素 arr[front] 就是队列的第一个元素

  初始值为0

  2.rear  含义调整：指向队列最后一个元素的后一个位置，因为希望空出一个空间做约定

  初始值为0

  3.当队列满时 条件是：(rear+1)%maxSize=front

  4.队列为空： rear=front

  5.有效个数：(rear+maxSize-front)%maxSize

 [代码](E:\YangChengCan\Learning\数据结构与算法学习\代码\DataStructures\src\com\yangcc\queue)

### 三、链表

* 无序的单链表
* 有序的单链表

  * 1.找到新添加的节点的位置，通过辅助指针（temp）来寻找，通过遍历
* 2.让新节点的下一个.next =temp.next
  * 3.temp.next =新的节点


##### 删除

1.先找到需要删除的前一个节点

2.temp.next =temp.next.next

3.被删除的节点将不会有其他引用指向，会被垃圾回收机制回收

#### 总结：

* 只要链表中出现指向改变的情况，为了保证 指向关联，则比较时一定要用temp的下一个节点进行比较

[代码](E:\YangChengCan\Learning\数据结构与算法学习\代码\DataStructures\src\com\yangcc\linkedlist)

#### 面试题

* 求单链表中有效节点的个数
* 查找链表中倒数第k个节点【新浪面试题】
* 单链表的反转【腾讯面试题】第22课

  * 1.先定义一个新节点
  * 2.从旧链表依次取出并加入到新链表最前面
* 从尾到头打印链表【百度】 
  * 使用栈

* 合并两个有序链表，合并后依然有序
  * 创建一个新链表，并分别遍历两张链表，按顺序依次加入到新链表

[代码](E:\YangChengCan\Learning\数据结构与算法学习\代码\DataStructures\src\com\yangcc\linkedlist)

#### 双向链表

分析双向链表的遍历，添加，修改，删除的操作思路

[代码](E:\YangChengCan\Learning\数据结构与算法学习\代码\DataStructures\src\com\yangcc\linkedlist)

#### 环形链表（29课）

约瑟夫问题

![1564487184074](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1564487184074.png)

分析

* 需要创建一个辅助指针helper，事先应该指向环形链表的最后这个节点

* 报数前，先让frist和helper移动k-1次

* 当小孩报数时，让frist和helper指针同事移动m-1次

* 此时将frist指向的小孩节点出圈

  frist=frist.next

  helper.next=first

  [代码](E:\YangChengCan\Learning\数据结构与算法学习\代码\DataStructures\src\com\yangcc\linkedlist\Josephu.java)

### 四、栈

1.英文为stack

2.先进后出

3.限制线性表中元素的插入和删除只能在线性表同一端进行的一种特殊线性表，允许插入和删除的一端，为变化的一端，称为栈顶，另一端为固定的一段，称为栈底

4.应用场景

* 子程序的调用，在跳往子程序前，会将下个指令的地址存到堆栈中，知道子程序执行完再将地址取出，以回到原来的程序中
* 处理递归调用：同子程序类似，除了储存下一个指令的地址外，也将参数，区域遍历等数据存入堆栈中
* 表达式的转换与求值（实际解决）
* 二叉树的遍历
* 图形的深度优先  搜索法

5.规定：出栈方法是pop，入栈是push

##### 实现栈的思路分析（32课）

* **数组**

1.使用数组来模拟栈

2.定义一个top表示栈顶，初始化为-1

3.入栈的操作，当有数据加入栈时，top++，stack[top]=data;

4.出栈的操作，int value =stack[top],top--;return value

[代码](E:\YangChengCan\Learning\数据结构与算法学习\代码\DataStructures\src\com\yangcc\stack\ArrayStackDemo.java)

* 用栈实现计算器（33课）(中缀表达式)

1.创建两个栈，数字栈和符号栈

2.通过一个index值（索引），遍历表达式

3.如果发现的是一个数字，直接入栈

4.如果发现的是一个符号，进行比较

* 如果当前的操作符的优先级小于或等于栈中的操作符，就需要从数栈中pop出两个数，从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈
* 如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈

5.当表达式扫描完毕，就顺序的从数栈和呼号栈中pop出相应的数和符号，并运行，

6.最后在数栈中只有一个数字，就是表达式的结果

[代码](E:\YangChengCan\Learning\数据结构与算法学习\代码\DataStructures\src\com\yangcc\stack\Calculator.java)

**前缀，中缀，后缀表达式（逆波兰表达式）**

* 前缀：波兰表达式，运算符都位于操作数之前

  如（3+4）*5-6 对应前缀表达式为-  * + 3 4 5 6

* 中缀

* 后缀：

  如 a+(b-c)*d    a b c - d * +

  a+d *(b-c)    a d b c - * +

**逆波兰计算器**

​    1.使用stack，计算输入的结果

​	2.支持小括号和多位数整数

​	3.思路：

​		遇到数则入栈，遇到符号则将数的顶上两个弹出计算并再入栈

**中缀表达式转为后缀表达式（算法）**（39课）  

​	后缀表达式适合计算器计算，但人不太容易写出来，实际开发中需要转化

​	例子：1+ ((2+3)*4 )-5 

* 具体步骤

  * 1.初始化两个栈，运算符栈s1和储存中间结果的栈s2
  *  2.从左至右扫描中缀表达式
  * 3.遇到操作数时，压入到s2
  * 4.遇到运算符时，比较其与s1栈顶运算符的优先级
    * 4.1 如果s1为空，或栈顶运算符为左括号“(”,则直接将运算符如栈
    * 4.2 若优先级比栈顶运算符高，也将运算符压入s1
    * 4.3 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到（4.1）与s1中新的栈顶运算符相比较

  * 5.遇到括号时
    * 1.如果时左括号"(" 则直接压入S1
    * 2.如果是“)” ，则依次弹出S1栈顶的运算符，并压入S2,直到遇到左括号位置，此时将这一对括号丢弃
  * 6.重复步骤2-5，直到表达式的最右边
  * 7.将s1中剩余的运算符依次弹出压入s2
  * 8.依次弹出s2中元素并进行输出，结果的逆序几位中缀表达式对应的后缀表达式

  [代码](E:\YangChengCan\Learning\数据结构与算法学习\代码\DataStructures\src\com\yangcc\stack\PolandNotation.java)

