### 继承 P152-

继承是多态的前提

继承主要解决的问题：**共性抽取**

父类 （基类 、超类）

子类（派生类）

* 在父子类的继承关系中，如果成员变量重名，则创建子类对象时，访问时两种规则

  1.通过子类对象访问成员变量

  ​	等号左边是谁，就优先访问谁，没有则往上找，没有则编译报错

  2.间接通过成员方法访问成员变量

  ​	方法属于谁，就优先用谁，没有，则向上找

  

* 父子类对象访问成员变量和规则

  super. 父类的成员变量

  this.本类成员变量

* 父子类中访问成员方法规则

  1.创建对象是谁，优先用谁，没有则向上找

  2.注：无论是成员方法或变量，没有往上找

* 重写（覆盖） override 

  在继承关系中，方法名称一样，参数列表一样

  特点：1.创建子类对象，则优先用子类

  @Override 注解 如果没报错，则是正确的覆盖

  2.子类中的返回值，必须小于父类的范围

  3.子类方法的权限，必须大于等于父类权限修饰符

  public >protected >default>private 

* 父子类构造方法的特点

  1.子类构造方法中又一个默认隐含的super();调用，所以一定先是父类构造

  2.子类构造可以通过super关键字调用父类重载构造

  3.super父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造

  **子类必须调用父类构造方法，不写则赠送super();写了则用指定的super调用，super只能是第一个**

* super关键字

  1.子类成员方法中，访问父类成员变量

  2.子类成员方法中，访问父类的成员方法

  3.子类构造方法中，访问父类的构造方法

* this关键字

  1.本类成员方法中，访问本类成员变量（局部变量和成员变量名称相同）

  2.本类的成员方法中，访问本类的另一个成员方法

  3.本类的构造方法中，访问另一个构造方法；注：this必须是第一个语句，唯一一个

* this和super图解

  ![1571752198050](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1571752198050.png)

* java与继承相关三个特征

  1.单继承

  2.可多级继承

  3.子类的父类是唯一的，但一个父类可以有多个子类

### 抽象 165-

不确定具体的方法

public abstract void method();

* 使用抽象类和抽象方法

  1.不能直接创建new抽象类对象

  2.必须用一个子类继承父类

  3.子类必须覆盖抽象类所有抽象方法，去掉abstract并补上大括号，否则，子类必须也属于抽象类

  4.创建子类对象进行使用

  5.抽象类不一定有抽象方法，但有抽象方法一定是抽象类

*  

#### 接口  P171-

接口是多个类的公共规范

接口是一种引用数据类型，最重要的内容就是其中的，抽象方法

public interface 接口名称{

}

* 接口使用步骤

  1.不能直接使用，必须有一个实现类来实现该接口

  2.接口的实现类必须覆盖重写接口的所有的抽象方法

  3.创建实现类的对象

  注：如果实现类未覆盖接口中所有方法，那该类必须为抽象类

* 接口的默认方法

  public default void method(){}

  可解决接口升级的问题

  可以在子类对象中直接调用，也可以被接口实现类进行覆盖，重写

* 从java8开始，接口中允许定义静态方法

  不能通过接口实现类对象，调用接口当中的静态方法

  正确用法：通过接口名称直接调用其中的静态方法

*  从java9开始，接口中允许使用私有方法，能解决多个默认/静态方法之间重复代码问题

* 接口中可以定义成员变量，但必须使用public static final三个关键字进行修饰（可省略）

  1.一旦使用final进行修饰，说明不可变、

  2.接口中的常量，必须进行赋值，不能不赋值

  3.接口中常量的名称使用完全大写，并用下划线进行分割 

* 

#### P183 继承父类并实现多个接口 

* 如果实现类的多个接口有重复的抽象方法，则只需实现其中一个即可
* 如果实现类实现的多个接口中，存在重复的默认方法，那么实现类一定要对默认的方法进行覆盖重写 ，不重复的默认方法可以不用覆盖
* 继承要优先于接口实现

#### P184接口之间的多继承

* 类于类之间是单继承
* 类于接口之间是多实现，一个类可以实现多个接口
* 接口于接口是多继承的

注意：多个父接口中抽象方法重复，没关系

多个接口中默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，而且带着default关键字



### 多态 P185-

* 多态格式及使用

  父类名称  对象名=new 子类名称（）；

  接口名称  对象名=new 实现类名称（）；

* 访问成员变量两种形式

  直接通过对象名访问，左边等号是谁，优先用谁，没有则向上找

* 成员变量 ：编译看左边，运行还是看左边

  成员方法：编译看左边，运行看右边

* 上下转型

  向上转型：就是多态写法，父类引用指向子类对象，即创建一个子类对象，把它当作子类看待使用（向上转型一定是安全的）；弊端是，对象一旦向上转型为父类，那么就无法调用子类原本持有的内容

  向下转型：其实是一个还原的动作

  格式：子类名称  对象名 =（子类名称） 父类对象

  含义：将父类对象还原为子类对象

  ![image-20191028195619778](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20191028195619778.png)

* 如何才能直到一个父类引用的对象，本来是什么子类

   **对象 instanceof 类型**

  animal instanceof dog

  将会得到一个布尔值，也就是判断前面对象能不能当作后面对象的实例

* 作用：传参时传的父类，使用时使用子类特有的方法

#### P195 final和内部类

final四种用法：

1.修饰类

​	public final class 类名{}

​	当前这个类不能又任何的子类，但是有父类

2.方法

​	这个方法为最终方法，不能被覆盖重写

abstract和final不能同时使用，因为矛盾

3.局部变量

​	不能被改变，只能赋值一次

​	但引用类型中地址不可变，内容可变

4.成员变量

​	由于成员变量有默认值，所以用了final之后必须手动赋值，不会再给默认值 了；要么直接赋值，要么通过构造方法赋值

#### p200 权限修饰符

1.同一类

2.同一个包

3.不同包子类  

4.不同包非子类

#### p201 内部类

一个事物的内部包含另一个事物

分类：

* 成员内部类

  1.修饰符 class 类名{

  ​	修饰符 class 类名{

  ​	}

  }

  内用外可以随便访问，外用内则一定要借助内部类对象

  如果出现重名现象

  ![image-20191028212252928](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20191028212252928.png)

* 局部内部类（包含匿名内部类）

  在方法里面定义

* 权限修饰符

  外部类：public default

  成员内部类：public / protected/default/private 

  局部内部类：什么都不能写

#### P207 匿名内部类

如果接口实现类或者子类只需要使用一次，则可省略该类的定义，而改为使用【匿名内部类】

* 定义格式：

  接口名称 对象名=new 接口名称(){

  ​	覆盖重写所有抽象方法

  }；

  可省掉一个类的单独定义

* 注意事项：

  1.匿名内部类在创建对象时，只能使用唯一一次，如果希望多次创建对象，且内容一样的话，则使用单独实现类

  **匿名对象**：只能调用一次方法

  匿名对象和匿名内部类不是同一回事，  new interface(){}

  即是匿名内部类，也是匿名对象

#### p209-211接口作为变量，对象





#### P212-214 发红包案例













